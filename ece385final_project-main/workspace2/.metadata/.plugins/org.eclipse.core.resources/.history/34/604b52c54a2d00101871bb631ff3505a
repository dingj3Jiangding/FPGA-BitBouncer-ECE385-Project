#include "player.h"
#include <stdint.h>
#include "map.h"
#include <stdio.h>
#include <stdlib.h>

// 32x32 pixel dinosaur image data
uint8_t player_img[1024] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x09, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x09, 0x05, 0x05,
    0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x09, 0x09, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x05,
    0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x09, 0x09, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x09, 0x09, 0x09, 0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x05, 0x05, 0x05,
    0x05, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x09, 0x09, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x09, 0x09, 0x09, 0x00, 0x00, 0x00, 0x05, 0x05, 0x05, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x05, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x09, 0x09, 0x09, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x07, 0x07, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x07, 0x07, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x09, 0x09, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x07, 0x00, 0x09, 0x09, 0x09, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x09, 0x09, 0x09, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x07, 0x07, 0x00, 0x09, 0x09, 0x09, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x09, 0x09, 0x09, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x07, 0x00, 0x00, 0x09, 0x09, 0x09, 0x00, 0x00,
    0x05, 0x00, 0x00, 0x00, 0x00, 0x05, 0x07, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
    0x05, 0x05, 0x00, 0x00, 0x05, 0x05, 0x07, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,
    0x07, 0x07, 0x00, 0x00, 0x07, 0x07, 0x07, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,
    0x07, 0x07, 0x00, 0x00, 0x07, 0x07, 0x07, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,
    0x07, 0x07, 0x00, 0x00, 0x07, 0x07, 0x07, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
    0x07, 0x05, 0x05, 0x05, 0x05, 0x05, 0x07, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x05, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x05, 0x05, 0x07, 0x07, 0x07, 0x07, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
    0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x07, 0x00, 0x00, 0x07, 0x05, 0x07, 0x00, 0x00,
    0x07, 0x05, 0x07, 0x00, 0x00, 0x07, 0x07, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x07, 0x00, 0x00, 0x07, 0x05, 0x07, 0x00, 0x00,
    0x07, 0x05, 0x07, 0x00, 0x00, 0x07, 0x05, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x07, 0x07, 0x05, 0x00, 0x05, 0x07, 0x07,
    0x05, 0x00, 0x05, 0x07, 0x07, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x05, 0x00, 0x00, 0x05, 0x05,
    0x05, 0x00, 0x00, 0x05, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x05,
    0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};


// Store the last position of the player for clearing
static uint16_t last_x_pos = 0;
static uint16_t last_y_pos = 0;
static uint8_t first_draw = 1;  // Flag to check if this is the first draw

/**
 * Creates a new Player_animation node
 */
struct Player_animation* create_player_node(uint16_t x, uint16_t y, uint8_t direction, uint8_t jumping) {
    struct Player_animation* node = (struct Player_animation*)malloc(sizeof(struct Player_animation));
    if (node != NULL) {
        node->is_present = 1;
        node->x = x;
        node->y = y;
        node->direction = direction;
        node->jumping = jumping;
        node->fptr = NULL;
    }
    return node;
}

/**
 * Creates a run animation sequence for the dinosaur
 * Returns a pointer to the start of the animation cycle
 */
struct Player_animation* create_run_animation(uint16_t start_x) {
    // Create the first node (head of animation)
    struct Player_animation* head = create_player_node(start_x, GROUND_LEVEL - DINO_HEIGHT, 0, 0);
    struct Player_animation* current = head;

    // Create a simple animation with 4 frames
    // Frame 2: Moving right leg forward
    current->fptr = create_player_node(start_x, GROUND_LEVEL - DINO_HEIGHT, 0, 0);
    current = current->fptr;

    // Frame 3: Both legs mid-stride
    current->fptr = create_player_node(start_x, GROUND_LEVEL - DINO_HEIGHT, 0, 0);
    current = current->fptr;

    // Frame 4: Moving left leg forward
    current->fptr = create_player_node(start_x, GROUND_LEVEL - DINO_HEIGHT, 0, 0);
    current = current->fptr;

    // Link back to the first frame to create a loop
    current->fptr = head;

    return head;
}

/**
 * Creates a jump animation sequence
 * Returns a pointer to the start of the animation sequence
 */
struct Player_animation* create_jump_animation(uint16_t start_x) {
    // Create the first node (head of animation)
    struct Player_animation* head = create_player_node(start_x, GROUND_LEVEL - DINO_HEIGHT, 0, 1); // Mark as jumping
    struct Player_animation* current = head;

    // Create a simple 8-frame jumping animation
    // Frame 2-4: Rising
    for (int i = 1; i <= 3; i++) {
        uint16_t new_y = (GROUND_LEVEL - DINO_HEIGHT) - (JUMP_HEIGHT * i / 3);
        current->fptr = create_player_node(start_x, new_y, 0, 1);
        current = current->fptr;
    }

    // Frame 5: At apex of jump
    current->fptr = create_player_node(start_x, (GROUND_LEVEL - DINO_HEIGHT) - JUMP_HEIGHT, 0, 1);
    current = current->fptr;

    // Frame 6-8: Falling
    for (int i = 1; i <= 3; i++) {
        uint16_t new_y = ((GROUND_LEVEL - DINO_HEIGHT) - JUMP_HEIGHT) + (JUMP_HEIGHT * i / 3);
        current->fptr = create_player_node(start_x, new_y, 0, 1);
        current = current->fptr;
    }

    // Last frame: Back to ground level, NOT jumping anymore
    current->fptr = create_player_node(start_x, GROUND_LEVEL - DINO_HEIGHT, 0, 0); // Not jumping
    current = current->fptr;

    // Don't link back to head - set to NULL to indicate end of jump
    current->fptr = NULL;

    return head;
}

/**
 * Frees an animation sequence linked list
 * Must check if the animation is a loop to avoid infinite recursion
 */
void free_animation(struct Player_animation* head) {
    if (head == NULL) return;

    // To handle loops, we'll manually break the loop and then free
    struct Player_animation* current = head;
    struct Player_animation* start = head;
    int visited_head_again = 0;

    while (current != NULL && !visited_head_again) {
        struct Player_animation* next = current->fptr;

        // Check if we're back at the head (loop detected)
        if (next == start) {
            current->fptr = NULL;  // Break the loop
            visited_head_again = 1;
        }

        free(current);
        current = next;
    }
}

/**
 * Clears the player from its last position
 */
void clear_player(BRAM_t* hdmi_ctrl) {
    // Skip clearing if this is the first draw
    if (first_draw) {
        first_draw = 0;
        return;
    }

    // Clear the area where the player was last drawn
    for (int y = 0; y < DINO_HEIGHT; y++) {
        for (int x = 0; x < DINO_WIDTH; x++) {
            uint16_t screen_x = last_x_pos + x;
            uint16_t screen_y = last_y_pos + y;

            // Convert to byte position and bit position
            uint32_t byte_pos = screen_y * (SCREEN_WIDTH/2) + (screen_x/2);
            uint8_t is_right_pixel = screen_x % 2; // 1 if right pixel, 0 if left

            // Ensure we don't write outside the buffer
            if (byte_pos < (SCREEN_HEIGHT * SCREEN_WIDTH/2)) {
                // Read existing byte to preserve the other pixel
                uint8_t current_byte = hdmi_ctrl->VRAM[byte_pos];

                if (is_right_pixel) {
                    // Clear right pixel (lower 4 bits)
                    hdmi_ctrl->VRAM[byte_pos] = current_byte & 0xF0;
                } else {
                    // Clear left pixel (upper 4 bits)
                    hdmi_ctrl->VRAM[byte_pos] = current_byte & 0x0F;
                }
            }
        }
    }

    // Redraw ground line if we cleared part of it
    if (last_y_pos + DINO_HEIGHT >= GROUND_LEVEL) {
        int start_y = (last_y_pos + DINO_HEIGHT >= GROUND_LEVEL) ? GROUND_LEVEL : last_y_pos + DINO_HEIGHT;
        int end_y = (last_y_pos + DINO_HEIGHT > SCREEN_HEIGHT) ? SCREEN_HEIGHT : last_y_pos + DINO_HEIGHT;

        for (int y = start_y; y < end_y; y++) {
            for (int x = last_x_pos; x < last_x_pos + DINO_WIDTH; x++) {
                if (x >= 0 && x < SCREEN_WIDTH && y >= 0 && y < SCREEN_HEIGHT) {
                    if (y == GROUND_LEVEL) {
                        hdmi_ctrl->VRAM[y * SCREEN_WIDTH + x] = 0x55; // Gray ground
                    }
                }
            }
        }
    }
}

/**
 * Draws a single frame of the dinosaur
 */
void draw_player(struct Player_animation* player, BRAM_t* hdmi_ctrl) {
    // Only draw if player is present
    if (player->is_present) {
        // Get position from the player struct
        uint16_t x_pos = player->x;
        uint16_t y_pos = player->y;

        // Clear the player from the previous position
        clear_player(hdmi_ctrl);

        // Save current position for next clear operation
        last_x_pos = x_pos;
        last_y_pos = y_pos;

        // Color mapping for the new image array (0x00 to 0x0C)
        const uint32_t COLOR_MAP[] = {
            0x000000,  // 0x00: Black/transparent
            0x333333,  // 0x01: Dark gray
            0x555555,  // 0x02: Gray
            0x777777,  // 0x03: Light gray
            0x999999,  // 0x04: Lighter gray
            0xBBBBBB,  // 0x05: Very light gray
            0xDDDDDD,  // 0x06: Almost white
            0xFFFFFF,  // 0x07: White
            0x00FF00,  // 0x08: Green
            0x00AA00,  // 0x09: Dark green
            0x00DD00,  // 0x0A: Light green
            0x00CC00,  // 0x0B: Medium green
            0x00EE00   // 0x0C: Bright green
        };

        // Draw the dinosaur pixel by pixel using the image array
        for (int y = 0; y < DINO_HEIGHT; y++) {
            for (int x = 0; x < DINO_WIDTH; x++) {
                // For left-facing direction, read pixels in reverse order horizontally
                int read_x = (player->direction == 0) ? x : (DINO_WIDTH - 1 - x);

                // Get the pixel value from the player_img array
                uint8_t pixel_value = player_img[y * DINO_WIDTH + read_x];

                // Only draw non-zero pixels (0 is considered transparent)
                if (pixel_value > 0) {
                    // Calculate position in the HDMI buffer
                    uint16_t screen_x = x_pos + x;
                    uint16_t screen_y = y_pos + y;

                    // Convert to byte position and bit position
                    uint32_t byte_pos = screen_y * (SCREEN_WIDTH/2) + (screen_x/2);
                    uint8_t is_right_pixel = screen_x % 2; // 1 if right pixel, 0 if left

                    // Ensure we don't write outside the buffer
                    if (byte_pos < (SCREEN_HEIGHT * SCREEN_WIDTH/2)) {
                        // Map the pixel value to a color
                        uint8_t color = (pixel_value <= 0x0C) ? (pixel_value & 0x0F) : 0x0F;

                        // Read existing byte to preserve the other pixel
                        uint8_t current_byte = hdmi_ctrl->VRAM[byte_pos];

                        if (is_right_pixel) {
                            // Update right pixel (lower 4 bits)
                            hdmi_ctrl->VRAM[byte_pos] = (current_byte & 0xF0) | color;
                        } else {
                            // Update left pixel (upper 4 bits)
                            hdmi_ctrl->VRAM[byte_pos] = (current_byte & 0x0F) | (color << 4);
                        }
                    }
                }
            }
        }
    }
}

/**
 * Updates and draws the animation
 * frame_counter: Global counter for timing animations
 * Returns: Pointer to the current animation frame
 */
struct Player_animation* update_and_draw_animation(
    struct Player_animation* current_frame,
    BRAM_t* hdmi_ctrl,
    int* frame_counter
) {
    // Draw the current frame
    draw_player(current_frame, hdmi_ctrl);

    // Update frame counter
    (*frame_counter)++;

    // Advance to the next frame when counter reaches animation speed
    if (*frame_counter >= ANIMATION_SPEED) {
        *frame_counter = 0;

        // Move to the next frame if available
        if (current_frame->fptr != NULL) {
            current_frame = current_frame->fptr;
        } else {
            // If we've reached the end of animation (NULL), this means jump is complete
            // The main loop should handle transitioning back to run animation
        }
    }

    return current_frame;
}

/**
 * Handle jumping transition
 * When jump button is pressed, switch to jump animation
 */
struct Player_animation* handle_jump_input(
    int jump_button_pressed,
    struct Player_animation* current_frame,
    struct Player_animation* run_animation,
    struct Player_animation* jump_animation
) {
    // If jump button pressed and currently in run animation (not jumping)
    if (jump_button_pressed && !current_frame->jumping) {
        return jump_animation;  // Switch to jump animation
    }

    return current_frame;  // Keep current animation
}

/**
 * Reset the first_draw flag - useful when changing screens or restarting the game
 */
void reset_player_drawing() {
    first_draw = 1;
}

/**
 * Update all animation frames to a new position
 */
void update_all_animation_positions(struct Player_animation* anim, uint16_t x, uint16_t y, uint8_t direction) {
    if (anim == NULL) return;

    struct Player_animation* current = anim;
    struct Player_animation* start = anim;

    do {
        current->x = x;
        if (y != 0) current->y = y;  // Only update Y if provided (non-zero)
//        current->y = y;
        current->direction = direction;
        current = current->fptr;
    } while (current != NULL && current != start);
}

/**
 * Reset jump animation to its initial state
 */
void reset_jump_animation(struct Player_animation* jump_anim, uint16_t start_x) {
    if (jump_anim == NULL) return;

    struct Player_animation* current = jump_anim;

    // Reset first frame
    current->x = start_x;
    current->y = GROUND_LEVEL - DINO_HEIGHT;
    current->jumping = 1;
    current = current->fptr;

    // Reset rising frames
    for (int i = 1; i <= 3 && current != NULL; i++) {
        current->x = start_x;
        current->y = (GROUND_LEVEL - DINO_HEIGHT) - (JUMP_HEIGHT * i / 3);
        current->jumping = 1;
        current = current->fptr;
    }

    // Reset apex frame
    if (current != NULL) {
        current->x = start_x;
        current->y = (GROUND_LEVEL - DINO_HEIGHT) - JUMP_HEIGHT;
        current->jumping = 1;
        current = current->fptr;
    }

    // Reset falling frames
    for (int i = 1; i <= 3 && current != NULL; i++) {
        current->x = start_x;
        current->y = ((GROUND_LEVEL - DINO_HEIGHT) - JUMP_HEIGHT) + (JUMP_HEIGHT * i / 3);
        current->jumping = 1;
        current = current->fptr;
    }

    // Reset last frame (landing)
    if (current != NULL) {
        current->x = start_x;
        current->y = GROUND_LEVEL - DINO_HEIGHT;
        current->jumping = 0;  // Not jumping
    }
}
