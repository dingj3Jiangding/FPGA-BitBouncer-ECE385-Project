
#include "player.h"
#include <stdint.h>
#include "map.h"

// 32x32 pixel dinosaur image
// 0x00 = background (transparent)
// 0x01 = dark green (outline)
// 0x02 = medium green (body)
// 0x03 = light green (highlights)
// 0x04 = bright green (details)
uint8_t player_img[1024] = {
    0x0a, 0x0a, 0x0c, 0x01, 0x05, 0x08, 0x08, 0x01, 0x08, 0x08, 0x02, 0x01, 0x01, 0x04, 0x09, 0x01,
    0x01, 0x09, 0x04, 0x01, 0x01, 0x02, 0x08, 0x08, 0x01, 0x08, 0x08, 0x05, 0x01, 0x0c, 0x0a, 0x0a,
    0x0a, 0x0a, 0x0c, 0x01, 0x05, 0x08, 0x08, 0x01, 0x08, 0x08, 0x02, 0x01, 0x01, 0x07, 0x01, 0x01,
    0x01, 0x09, 0x04, 0x01, 0x01, 0x00, 0x08, 0x08, 0x01, 0x08, 0x08, 0x05, 0x01, 0x0c, 0x0a, 0x0a,
    0x0c, 0x0c, 0x05, 0x09, 0x0a, 0x0c, 0x06, 0x01, 0x00, 0x0c, 0x08, 0x01, 0x0c, 0x01, 0x01, 0x09,
    0x0c, 0x01, 0x0c, 0x05, 0x01, 0x01, 0x0c, 0x00, 0x01, 0x06, 0x0c, 0x0a, 0x09, 0x05, 0x0c, 0x0c,
    0x01, 0x01, 0x09, 0x08, 0x01, 0x01, 0x06, 0x0b, 0x00, 0x01, 0x02, 0x0c, 0x01, 0x02, 0x09, 0x00,
    0x08, 0x01, 0x01, 0x09, 0x04, 0x08, 0x01, 0x00, 0x0b, 0x06, 0x01, 0x01, 0x08, 0x09, 0x01, 0x01,
    0x05, 0x05, 0x0a, 0x02, 0x06, 0x0c, 0x08, 0x02, 0x08, 0x00, 0x0c, 0x01, 0x00, 0x0c, 0x01, 0x01,
    0x00, 0x00, 0x00, 0x01, 0x05, 0x01, 0x09, 0x02, 0x0a, 0x08, 0x0c, 0x06, 0x02, 0x0a, 0x05, 0x05,
    0x08, 0x08, 0x01, 0x01, 0x00, 0x0b, 0x08, 0x01, 0x08, 0x01, 0x01, 0x05, 0x01, 0x09, 0x0a, 0x01,
    0x0a, 0x0a, 0x04, 0x0c, 0x02, 0x01, 0x08, 0x01, 0x01, 0x08, 0x0b, 0x00, 0x01, 0x01, 0x08, 0x08,
    0x08, 0x08, 0x06, 0x02, 0x08, 0x08, 0x00, 0x04, 0x0a, 0x01, 0x00, 0x08, 0x09, 0x09, 0x07, 0x01,
    0x01, 0x01, 0x03, 0x08, 0x02, 0x0b, 0x0b, 0x01, 0x04, 0x00, 0x08, 0x08, 0x02, 0x06, 0x08, 0x08,
    0x01, 0x01, 0x01, 0x0b, 0x01, 0x01, 0x00, 0x05, 0x01, 0x07, 0x06, 0x04, 0x06, 0x06, 0x06, 0x07,
    0x07, 0x0b, 0x00, 0x09, 0x00, 0x06, 0x0a, 0x01, 0x04, 0x06, 0x01, 0x01, 0x0b, 0x01, 0x01, 0x01,
    0x08, 0x08, 0x00, 0x06, 0x08, 0x04, 0x01, 0x02, 0x07, 0x05, 0x00, 0x06, 0x00, 0x00, 0x0a, 0x0b,
    0x06, 0x0b, 0x09, 0x01, 0x03, 0x00, 0x08, 0x04, 0x02, 0x00, 0x00, 0x08, 0x06, 0x00, 0x08, 0x08,
    0x08, 0x08, 0x01, 0x01, 0x01, 0x03, 0x04, 0x00, 0x02, 0x0c, 0x09, 0x03, 0x02, 0x02, 0x09, 0x09,
    0x09, 0x0a, 0x09, 0x02, 0x00, 0x0b, 0x0b, 0x01, 0x01, 0x0a, 0x04, 0x00, 0x01, 0x01, 0x08, 0x08,
    0x02, 0x02, 0x08, 0x0b, 0x06, 0x01, 0x0b, 0x06, 0x05, 0x06, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0a,
    0x0a, 0x0b, 0x0b, 0x06, 0x05, 0x02, 0x07, 0x0a, 0x01, 0x0b, 0x05, 0x06, 0x0a, 0x08, 0x02, 0x02,
    0x01, 0x01, 0x09, 0x08, 0x0c, 0x05, 0x0b, 0x0a, 0x0c, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
    0x05, 0x05, 0x05, 0x05, 0x07, 0x00, 0x01, 0x09, 0x0a, 0x02, 0x01, 0x01, 0x07, 0x09, 0x01, 0x01,
    0x01, 0x08, 0x05, 0x09, 0x03, 0x03, 0x02, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
    0x03, 0x03, 0x03, 0x03, 0x07, 0x09, 0x0a, 0x0b, 0x0a, 0x0c, 0x01, 0x03, 0x0c, 0x05, 0x01, 0x01,
    0x04, 0x03, 0x01, 0x02, 0x02, 0x0c, 0x02, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
    0x06, 0x06, 0x02, 0x02, 0x07, 0x09, 0x02, 0x03, 0x09, 0x09, 0x02, 0x07, 0x01, 0x01, 0x04, 0x04,
    0x09, 0x0a, 0x0a, 0x03, 0x01, 0x05, 0x0a, 0x04, 0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x03, 0x03,
    0x03, 0x03, 0x0a, 0x03, 0x09, 0x05, 0x0b, 0x03, 0x09, 0x04, 0x04, 0x01, 0x01, 0x01, 0x09, 0x09,
    0x01, 0x0c, 0x05, 0x02, 0x07, 0x05, 0x04, 0x0c, 0x0a, 0x0a, 0x0a, 0x0a, 0x08, 0x08, 0x0a, 0x0a,
    0x0a, 0x07, 0x07, 0x0c, 0x06, 0x02, 0x0c, 0x0a, 0x03, 0x05, 0x06, 0x01, 0x09, 0x0a, 0x01, 0x01,
    0x01, 0x01, 0x02, 0x03, 0x08, 0x02, 0x05, 0x0b, 0x00, 0x03, 0x03, 0x00, 0x03, 0x02, 0x00, 0x07,
    0x07, 0x00, 0x05, 0x08, 0x02, 0x05, 0x00, 0x0a, 0x0b, 0x05, 0x0b, 0x06, 0x03, 0x00, 0x01, 0x01,
    0x09, 0x00, 0x01, 0x04, 0x04, 0x01, 0x0c, 0x0c, 0x01, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x01,
    0x01, 0x01, 0x06, 0x00, 0x00, 0x00, 0x01, 0x07, 0x06, 0x00, 0x00, 0x07, 0x01, 0x02, 0x00, 0x09,
    0x04, 0x01, 0x01, 0x0a, 0x02, 0x00, 0x0b, 0x01, 0x01, 0x02, 0x02, 0x01, 0x07, 0x08, 0x01, 0x01,
    0x0c, 0x06, 0x05, 0x08, 0x03, 0x07, 0x04, 0x07, 0x08, 0x00, 0x0c, 0x0a, 0x0a, 0x01, 0x01, 0x04,
    0x01, 0x0a, 0x0c, 0x02, 0x03, 0x0c, 0x01, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x09, 0x0b, 0x06, 0x0c, 0x04, 0x09, 0x08, 0x00, 0x07, 0x0c, 0x09, 0x0c, 0x0c, 0x01,
    0x01, 0x01, 0x0c, 0x0c, 0x0c, 0x08, 0x05, 0x0b, 0x05, 0x09, 0x0b, 0x00, 0x02, 0x00, 0x05, 0x0a,
    0x07, 0x01, 0x01, 0x07, 0x06, 0x0c, 0x04, 0x09, 0x08, 0x00, 0x07, 0x05, 0x05, 0x0c, 0x01, 0x01,
    0x02, 0x0b, 0x0b, 0x01, 0x09, 0x05, 0x08, 0x05, 0x05, 0x0b, 0x00, 0x07, 0x09, 0x04, 0x0b, 0x07,
    0x0b, 0x01, 0x07, 0x07, 0x06, 0x0c, 0x04, 0x09, 0x08, 0x00, 0x05, 0x04, 0x0b, 0x01, 0x0b, 0x02,
    0x08, 0x09, 0x01, 0x01, 0x09, 0x02, 0x08, 0x07, 0x06, 0x0c, 0x0b, 0x07, 0x0b, 0x07, 0x06, 0x07,
    0x0b, 0x07, 0x07, 0x07, 0x06, 0x02, 0x02, 0x09, 0x08, 0x00, 0x05, 0x04, 0x0b, 0x01, 0x00, 0x08,
    0x08, 0x08, 0x00, 0x0b, 0x0c, 0x0c, 0x06, 0x07, 0x09, 0x09, 0x08, 0x02, 0x0b, 0x0b, 0x06, 0x09,
    0x07, 0x07, 0x07, 0x09, 0x04, 0x05, 0x00, 0x04, 0x08, 0x00, 0x07, 0x05, 0x05, 0x01, 0x04, 0x08,
    0x01, 0x01, 0x0c, 0x0b, 0x04, 0x0b, 0x01, 0x00, 0x03, 0x04, 0x03, 0x06, 0x09, 0x05, 0x09, 0x04,
    0x01, 0x07, 0x07, 0x03, 0x00, 0x03, 0x0b, 0x06, 0x05, 0x04, 0x05, 0x0c, 0x06, 0x0c, 0x01, 0x01,
    0x08, 0x08, 0x06, 0x05, 0x01, 0x05, 0x00, 0x0c, 0x09, 0x0b, 0x0c, 0x01, 0x03, 0x08, 0x01, 0x09,
    0x01, 0x01, 0x01, 0x01, 0x0c, 0x03, 0x07, 0x0a, 0x05, 0x00, 0x05, 0x0c, 0x05, 0x01, 0x01, 0x08,
    0x08, 0x08, 0x01, 0x01, 0x09, 0x0a, 0x03, 0x09, 0x09, 0x0a, 0x09, 0x01, 0x01, 0x01, 0x01, 0x0b,
    0x00, 0x0b, 0x03, 0x0c, 0x05, 0x01, 0x02, 0x09, 0x06, 0x0b, 0x01, 0x09, 0x03, 0x01, 0x02, 0x08,
    0x05, 0x05, 0x0a, 0x02, 0x02, 0x03, 0x01, 0x0b, 0x09, 0x09, 0x09, 0x04, 0x01, 0x00, 0x01, 0x0b,
    0x08, 0x00, 0x04, 0x0b, 0x08, 0x0c, 0x0c, 0x0a, 0x01, 0x01, 0x05, 0x01, 0x01, 0x0a, 0x05, 0x05,
    0x01, 0x01, 0x09, 0x08, 0x02, 0x01, 0x0c, 0x04, 0x0a, 0x04, 0x09, 0x01, 0x06, 0x01, 0x01, 0x01,
    0x02, 0x05, 0x0b, 0x02, 0x0a, 0x01, 0x01, 0x05, 0x08, 0x07, 0x01, 0x08, 0x01, 0x09, 0x01, 0x01,
    0x0c, 0x0c, 0x05, 0x09, 0x0a, 0x0c, 0x00, 0x02, 0x01, 0x01, 0x01, 0x06, 0x05, 0x0c, 0x01, 0x02,
    0x06, 0x01, 0x01, 0x01, 0x0c, 0x08, 0x0c, 0x00, 0x01, 0x06, 0x0c, 0x0a, 0x09, 0x05, 0x0c, 0x0c,
    0x0a, 0x0a, 0x0c, 0x01, 0x05, 0x08, 0x08, 0x01, 0x02, 0x04, 0x0c, 0x01, 0x01, 0x04, 0x09, 0x01,
    0x01, 0x05, 0x00, 0x06, 0x01, 0x02, 0x08, 0x08, 0x01, 0x08, 0x08, 0x05, 0x01, 0x0c, 0x0a, 0x0a,
    0x0a, 0x0a, 0x0c, 0x01, 0x05, 0x08, 0x08, 0x01, 0x08, 0x08, 0x02, 0x01, 0x01, 0x04, 0x09, 0x01,
    0x01, 0x09, 0x04, 0x01, 0x01, 0x02, 0x08, 0x08, 0x01, 0x08, 0x08, 0x05, 0x01, 0x0c, 0x0a, 0x0a,
};



/**
 * Dinosaur Animation System
 * Uses linked list of Player_animation structures to create animations
 */

#include <stdio.h>
#include <stdlib.h>

// External reference to the dinosaur image array
extern uint8_t player_img[];

// Screen dimensions
#define SCREEN_WIDTH 640
#define SCREEN_HEIGHT 480

// Ground level position (y-coordinate)
#define GROUND_LEVEL (SCREEN_HEIGHT - 50)

// Jump height (pixels above ground level)
#define JUMP_HEIGHT 100

// Dinosaur dimensions
#define DINO_WIDTH 32
#define DINO_HEIGHT 32

// Animation speed control
#define ANIMATION_SPEED 5  // Update every 5 frames

/**
 * Creates a new Player_animation node
 */
struct Player_animation* create_player_node(uint16_t x, uint16_t y, uint8_t direction, uint8_t jumping) {
    struct Player_animation* node = (struct Player_animation*)malloc(sizeof(struct Player_animation));
    if (node != NULL) {
        node->is_present = 1;
        node->x = x;
        node->y = y;
        node->direction = direction;
        node->jumping = jumping;
        node->fptr = NULL;
    }
    return node;
}

/**
 * Creates a run animation sequence for the dinosaur
 * Returns a pointer to the start of the animation cycle
 */
struct Player_animation* create_run_animation(uint16_t start_x) {
    // Create the first node (head of animation)
    struct Player_animation* head = create_player_node(start_x, GROUND_LEVEL, 0, 0);
    struct Player_animation* current = head;

    // Create a simple animation with 4 frames
    // Frame 2: Moving right leg forward
    current->fptr = create_player_node(start_x + 5, GROUND_LEVEL, 0, 0);
    current = current->fptr;

    // Frame 3: Both legs mid-stride
    current->fptr = create_player_node(start_x + 10, GROUND_LEVEL, 0, 0);
    current = current->fptr;

    // Frame 4: Moving left leg forward
    current->fptr = create_player_node(start_x + 15, GROUND_LEVEL, 0, 0);
    current = current->fptr;

    // Link back to the first frame to create a loop
    current->fptr = head;

    return head;
}

/**
 * Creates a jump animation sequence
 * Returns a pointer to the start of the animation sequence
 */
struct Player_animation* create_jump_animation(uint16_t start_x) {
    // Create the first node (head of animation)
    struct Player_animation* head = create_player_node(start_x, GROUND_LEVEL, 0, 0);
    struct Player_animation* current = head;

    // Create a simple 8-frame jumping animation
    // Frame 2-4: Rising
    for (int i = 1; i <= 3; i++) {
        uint16_t new_y = GROUND_LEVEL - (JUMP_HEIGHT * i / 3);
        current->fptr = create_player_node(start_x + (5 * i), new_y, 0, 1);
        current = current->fptr;
    }

    // Frame 5: At apex of jump
    current->fptr = create_player_node(start_x + 20, GROUND_LEVEL - JUMP_HEIGHT, 0, 1);
    current = current->fptr;

    // Frame 6-8: Falling
    for (int i = 1; i <= 3; i++) {
        uint16_t new_y = (GROUND_LEVEL - JUMP_HEIGHT) + (JUMP_HEIGHT * i / 3);
        current->fptr = create_player_node(start_x + 20 + (5 * i), new_y, 0, 1);
        current = current->fptr;
    }

    // Link back to the run animation
    // Note: In a real game, you'd probably create a separate run animation
    // and link to it here rather than returning to the start of the jump
    current->fptr = head;

    return head;
}

/**
 * Frees an animation sequence linked list
 * Must check if the animation is a loop to avoid infinite recursion
 */
void free_animation(struct Player_animation* head) {
    if (head == NULL) return;

    // To handle loops, we'll manually break the loop and then free
    struct Player_animation* current = head;
    struct Player_animation* start = head;
    int visited_head_again = 0;

    while (current != NULL && !visited_head_again) {
        struct Player_animation* next = current->fptr;

        // Check if we're back at the head (loop detected)
        if (next == start) {
            current->fptr = NULL;  // Break the loop
            visited_head_again = 1;
        }

        free(current);
        current = next;
    }
}

/**
 * Draws a single frame of the dinosaur
 */
void draw_player(struct Player_animation* player, BRAM_t* hdmi_ctrl) {
    // Only draw if player is present
    if (player->is_present) {
        // Get position from the player struct
        uint16_t x_pos = player->x;
        uint16_t y_pos = player->y;

        // Color mapping for the new image array (0x00 to 0x0C)
        const uint32_t COLOR_MAP[] = {
            0x000000,  // 0x00: Black/transparent
            0x333333,  // 0x01: Dark gray
            0x555555,  // 0x02: Gray
            0x777777,  // 0x03: Light gray
            0x999999,  // 0x04: Lighter gray
            0xBBBBBB,  // 0x05: Very light gray
            0xDDDDDD,  // 0x06: Almost white
            0xFFFFFF,  // 0x07: White
            0x00FF00,  // 0x08: Green
            0x00AA00,  // 0x09: Dark green
            0x00DD00,  // 0x0A: Light green
            0x00CC00,  // 0x0B: Medium green
            0x00EE00   // 0x0C: Bright green
        };

        // Draw the dinosaur pixel by pixel using the image array
        for (int y = 0; y < DINO_HEIGHT; y++) {
            for (int x = 0; x < DINO_WIDTH; x++) {
                // Get the pixel value from the player_img array
                uint8_t pixel_value = player_img[y * DINO_WIDTH + x];

                // Only draw non-zero pixels (0 is considered transparent)
                if (pixel_value > 0) {
                    // Calculate position in the HDMI buffer
                    uint32_t pos = (y_pos + y) * SCREEN_WIDTH + (x_pos + x);

                    // Map the pixel value to a color and write to the buffer
                    uint32_t color = (pixel_value <= 0x0C) ? COLOR_MAP[pixel_value] : 0xFFFFFF;
                    hdmi_ctrl->VRAM[pos] = (uint8_t)(color & 0xFF);  // Store only the lowest byte
                }
            }
        }
    }
}

/**
 * Updates and draws the animation
 * frame_counter: Global counter for timing animations
 * Returns: Pointer to the current animation frame
 */
struct Player_animation* update_and_draw_animation(
    struct Player_animation* current_frame,
    BRAM_t* hdmi_ctrl,
    int* frame_counter
) {
    // Draw the current frame
    draw_player(current_frame, hdmi_ctrl);

    // Update frame counter
    (*frame_counter)++;

    // Advance to the next frame when counter reaches animation speed
    if (*frame_counter >= ANIMATION_SPEED) {
        *frame_counter = 0;

        // Move to the next frame if available
        if (current_frame->fptr != NULL) {
            current_frame = current_frame->fptr;
        }
    }

    return current_frame;
}

/**
 * Handle jumping transition
 * When jump button is pressed, switch to jump animation
 */
struct Player_animation* handle_jump_input(
    int jump_button_pressed,
    struct Player_animation* current_frame,
    struct Player_animation* run_animation,
    struct Player_animation* jump_animation
) {
    // If jump button pressed and currently in run animation (not jumping)
    if (jump_button_pressed && !current_frame->jumping) {
        return jump_animation;  // Switch to jump animation
    }

    return current_frame;  // Keep current animation
}

/**
 * Main game loop example
 */
// void game_loop_example() {
//     // Create animation sequences
//     struct Player_animation* run_animation = create_run_animation(100);
//     struct Player_animation* jump_animation = create_jump_animation(100);

//     // Initialize current frame to running animation
//     struct Player_animation* current_frame = run_animation;

//     // Create display buffer (in a real implementation, this would be your hardware framebuffer)
//     BRAM_t* display_buffer = (BRAM_t*)malloc(SCREEN_WIDTH * SCREEN_HEIGHT * sizeof(BRAM_t));

//     // Animation timing counter
//     int frame_counter = 0;

//     // Game loop (simplified)
//     int game_running = 1;
//     int jump_button_pressed = 0;

//     while (game_running) {
//         // Clear display buffer (set to background color)
//         // ...

//         // Check for input (simplified)
//         // In a real implementation, you'd check hardware inputs
//         // jump_button_pressed = check_jump_button();

//         // Handle jumping transitions
//         current_frame = handle_jump_input(
//             jump_button_pressed,
//             current_frame,
//             run_animation,
//             jump_animation
//         );

//         // Update and draw the current frame
//         current_frame = update_and_draw_animation(
//             current_frame,
//             display_buffer,
//             &frame_counter
//         );

//         // Update display (in a real implementation, this would refresh the hardware display)
//         // ...

//         // Reset jump button for next frame
//         jump_button_pressed = 0;

//         // Delay to control frame rate
//         // ...
//     }

//     // Free resources
//     free_animation(run_animation);
//     free_animation(jump_animation);
//     free(display_buffer);
// }
